"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShaderGraph = void 0;
const path_1 = require("path");
const js_yaml_1 = require("js-yaml");
const fs_extra_1 = require("fs-extra");
module.paths.push((0, path_1.join)(Editor.App.path, 'node_modules'));
const { Asset } = require('@editor/asset-db');
const block_forge_1 = require("../block-forge");
const shader_graph_1 = require("../shader-graph");
const utils_3_8_1 = require("./utils-3.8");
const VectorDataType = [
    'float',
    'vec2',
    'vec3',
    'vec4',
    'color',
    'enum',
    'boolean',
];
class ShaderGraph {
    constructor() {
        this.shaderNodeClassMap = new Map;
        /**
         * 用于存储每个 asset 对应的 source
         * 导入前先换成，把 source 替换成 temp 路径下的 effect
         * 导入后在替换成原本的 source
         */
        this.cacheSourceMap = new Map();
        this._initedGraph = false;
    }
    get assetType() {
        return 'cc.EffectAsset';
    }
    get version() {
        return '1.0.0';
    }
    get name() {
        return 'shader-graph';
    }
    get migrations() {
        return [];
    }
    reset() {
        this._initedGraph = false;
    }
    async initGraph() {
        if (this._initedGraph && this.shaderContext?.shaderTemplatesDir) {
            return;
        }
        await Editor.Module.importProjectModule('db://shader-graph/operation/index.ts');
        const { ShaderProperty } = await Editor.Module.importProjectModule('db://shader-graph/operation/property.ts');
        this.ShaderProperty = ShaderProperty;
        const { shaderNodeMap, shaderPropertyMap, shaderNodeClassMap } = await Editor.Module.importProjectModule('db://shader-graph/graph/index.ts');
        const { shaderContext } = await Editor.Module.importProjectModule('db://shader-graph/operation/context.ts');
        (0, shader_graph_1.declareShaderNodeBlock)(shaderNodeMap);
        this.shaderNodeClassMap = shaderNodeClassMap;
        this.shaderContext = shaderContext;
        shaderContext.shaderTemplatesDir = await Editor.Message.request('asset-db', 'query-path', 'db://shader-graph/../compile-shader/shader-templates');
        // shaderContext.shaderTemplatesDir = queryPath('db://shader-graph/../compile-shader/shader-templates');
        this._initedGraph = true;
    }
    createShaderNodes(blockMap) {
        const shaderNodeClassMap = this.shaderNodeClassMap;
        const shaderContext = this.shaderContext;
        for (const uuid in blockMap) {
            const block = blockMap[uuid];
            if (!block.desc)
                continue;
            const type = block.desc.type;
            let shaderNode = block.shaderNode;
            if (!shaderNode) {
                const cls = shaderNodeClassMap.get(type);
                if (!cls) {
                    console.error(`Can not find type for ${type}`);
                }
                shaderNode = new cls();
                shaderNode.init();
                shaderNode.block = block;
                if (!shaderContext.allNodes.includes(shaderNode)) {
                    shaderContext.allNodes.push(shaderNode);
                }
                if (type === 'RegisterLocalVar') {
                    if (!shaderContext.localVars.includes(shaderNode)) {
                        shaderNode.name = block.getInputPinsList()[1].value.value;
                        shaderContext.localVars.push(shaderNode);
                    }
                }
                if (type === 'GetLocalVar') {
                    if (!shaderContext.getLocalVars.includes(shaderNode)) {
                        shaderNode.name = block.getInputPinsList()[0].value.value;
                        shaderContext.getLocalVars.push(shaderNode);
                    }
                }
                if (type === 'PropertyNode') {
                    shaderNode.name = block.block.details.title;
                }
                const inputPins = block.getInputPinsList();
                for (let i = 0; i < inputPins.length; i++) {
                    const pin = inputPins[i];
                    const value = pin.value;
                    const input = shaderNode.inputs[i];
                    let slot = shaderNode.getSlotWithSlotName(pin.desc.name);
                    if (!slot) {
                        slot = shaderNode.getPropWithName(pin.desc.name);
                    }
                    if (VectorDataType.includes(value.dataType)) {
                        if (slot) {
                            if (typeof value.value === 'number' || typeof value.value === 'boolean') {
                                slot.value = value.value;
                            }
                            else if (value.dataType === 'color') {
                                // srgb to linear
                                slot.value.set(value.value.x * value.value.x, value.value.y * value.value.y, value.value.z * value.value.z, value.value.w);
                            }
                            else if (value.dataType === 'enum') {
                                slot.value = value.value;
                            }
                            else if (value.dataType === 'dynamicEnum') {
                                // TODO
                            }
                            else {
                                slot.value.set(value.value);
                            }
                        }
                    }
                }
                block.shaderNode = shaderNode;
            }
        }
    }
    searchInputs(block) {
        const shaderNode = block.shaderNode;
        const inputList = block.getInputPinsList();
        for (let i = 0; i < inputList.length; i++) {
            const pin = inputList[i];
            if (!shaderNode.inputs[i]) {
                continue;
            }
            const connectPin = pin.connectPins[0];
            if (connectPin) {
                const connectBlock = connectPin.block;
                const connectShaderNode = connectBlock.shaderNode;
                const connectOutIdx = connectPin.block.getOutputPinsList().indexOf(connectPin);
                const connectSlot = connectShaderNode.outputs[connectOutIdx];
                shaderNode.inputs[i].connectSlots[0] = connectSlot;
                connectSlot.connectSlots.push(shaderNode.inputs[i]);
                this.searchInputs(connectBlock);
            }
            else {
                shaderNode.inputs[i].connectSlots.length = 0;
            }
        }
    }
    async generateMasterNode(graphData) {
        await this.initGraph();
        const forge = new block_forge_1.Forge(graphData);
        const graph = forge.getGraph();
        this.shaderContext.reset();
        // TODO 这里还需要处理子图的 properties
        const properties = graph.details.properties;
        if (properties) {
            properties.forEach((v) => {
                const prop = new this.ShaderProperty(v.type);
                prop.name = v.name;
                prop.setValue(v.outputPins[0].value);
                this.shaderContext.properties.push(prop);
            });
        }
        const blockMap = graph.getBlockMap();
        await this.createShaderNodes(blockMap);
        let masterBlock;
        for (const uuid in blockMap) {
            const block = blockMap[uuid];
            if (!block.desc)
                continue;
            const type = block.desc.type;
            if (type.includes('MasterNode')) {
                masterBlock = block;
            }
        }
        if (!masterBlock) {
            throw new Error('Can not find MasterBlock');
        }
        for (let i = 0; i < this.shaderContext.localVars.length; i++) {
            const locVar = this.shaderContext.localVars[i];
            await this.searchInputs(locVar.block);
        }
        await this.searchInputs(masterBlock);
        const masterNode = masterBlock.shaderNode;
        return masterNode;
    }
    async generateEffectByGraphData(graphData) {
        const masterNode = await this.generateMasterNode(graphData);
        return masterNode.generateCode();
    }
    // @ts-expect-error
    async generateEffectByAsset(asset) {
        const serializeYAML = await (0, fs_extra_1.readFile)(asset.source, 'utf8');
        const graphData = (0, js_yaml_1.load)(serializeYAML);
        const code = await this.generateEffectByGraphData(graphData);
        (0, fs_extra_1.ensureDirSync)(this.tempEffectCodeDir);
        await (0, fs_extra_1.writeFile)(this.getTempEffectCodePath(asset), code);
        return code;
    }
    /**
     * 获取存储 effect code 文件夹
     */
    // @ts-expect-error
    getTempEffectCodePath(asset) {
        return (0, path_1.join)(this.tempEffectCodeDir, `${asset.uuid}.effect`);
    }
    /**
     * 获取存储 effect code 路径
     */
    get tempEffectCodeDir() {
        return (0, path_1.join)(Editor.Project.tmpDir, `shader-graph`);
    }
    /**
     * 返回是否导入成功的标记
     * 如果返回 false，则 imported 标记不会变成 true
     * 后续的一系列操作都不会执行
     * @param asset
     */
    // @ts-expect-error
    async import(asset) {
        await (0, utils_3_8_1.generateEffectAsset)(asset, await this.generateEffectByAsset(asset));
        return true;
    }
}
exports.ShaderGraph = ShaderGraph;
exports.default = new ShaderGraph();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhZGVyLWdyYXBoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ltcG9ydGVyL3NoYWRlci1ncmFwaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQkFBNEI7QUFDNUIscUNBQStCO0FBQy9CLHVDQUEwRTtBQUUxRSxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFBLFdBQUksRUFBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO0FBRXpELE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUU5QyxnREFBOEM7QUFFOUMsa0RBQXlFO0FBQ3pFLDJDQUFrRDtBQUVsRCxNQUFNLGNBQWMsR0FBRztJQUNuQixPQUFPO0lBQ1AsTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sT0FBTztJQUNQLE1BQU07SUFDTixTQUFTO0NBQ1osQ0FBQztBQUVGLE1BQWEsV0FBVztJQUF4QjtRQWtCSSx1QkFBa0IsR0FBcUIsSUFBSSxHQUFHLENBQUM7UUFJL0M7Ozs7V0FJRztRQUNJLG1CQUFjLEdBQXdCLElBQUksR0FBRyxFQUFFLENBQUM7UUFFdkQsaUJBQVksR0FBRyxLQUFLLENBQUM7SUF3T3pCLENBQUM7SUFuUUcsSUFBSSxTQUFTO1FBQ1QsT0FBTyxnQkFBZ0IsQ0FBQztJQUM1QixDQUFDO0lBRUQsSUFBSSxPQUFPO1FBQ1AsT0FBTyxPQUFPLENBQUM7SUFDbkIsQ0FBQztJQUVELElBQUksSUFBSTtRQUNKLE9BQU8sY0FBYyxDQUFDO0lBQzFCLENBQUM7SUFFRCxJQUFJLFVBQVU7UUFDVixPQUFPLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFlRCxLQUFLO1FBQ0QsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7SUFDOUIsQ0FBQztJQUVELEtBQUssQ0FBQyxTQUFTO1FBQ1gsSUFBSSxJQUFJLENBQUMsWUFBWSxJ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LENBQUM7SUFDaEUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxpQkFBaUI7UUFDeEIsT0FBTyxJQUFBLFdBQUksRUFBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxtQkFBbUI7SUFDWixLQUFLLENBQUMsTUFBTSxDQUFDLEtBQVk7UUFDNUIsTUFBTSxJQUFBLCtCQUFtQixFQUFDLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzFFLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Q0FDSjtBQXJRRCxrQ0FxUUM7QUFFRCxrQkFBZSxJQUFJLFdBQVcsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgbG9hZCB9IGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IHsgZW5zdXJlRGlyU3luYywgcmVhZEZpbGUsIHdyaXRlRmlsZSwgZXhpc3RzU3luYyB9IGZyb20gJ2ZzLWV4dHJhJztcblxubW9kdWxlLnBhdGhzLnB1c2goam9pbihFZGl0b3IuQXBwLnBhdGgsICdub2RlX21vZHVsZXMnKSk7XG5cbmNvbnN0IHsgQXNzZXQgfSA9IHJlcXVpcmUoJ0BlZGl0b3IvYXNzZXQtZGInKTtcblxuaW1wb3J0IHsgQmxvY2ssIEZvcmdlIH0gZnJvbSAnLi4vYmxvY2stZm9yZ2UnO1xuaW1wb3J0IHsgR3JhcGhEYXRhIH0gZnJvbSAnLi4vYmxvY2stZm9yZ2UvaW50ZXJmYWNlJztcbmltcG9ydCB7IElNb2R1bGVPcHRpb25zLCBkZWNsYXJlU2hhZGVyTm9kZUJsb2NrIH0gZnJvbSAnLi4vc2hhZGVyLWdyYXBoJztcbmltcG9ydCB7IGdlbmVyYXRlRWZmZWN0QXNzZXQgfSBmcm9tICcuL3V0aWxzLTMuOCc7XG5cbmNvbnN0IFZlY3RvckRhdGFUeXBlID0gW1xuICAgICdmbG9hdCcsXG4gICAgJ3ZlYzInLFxuICAgICd2ZWMzJyxcbiAgICAndmVjNCcsXG4gICAgJ2NvbG9yJyxcbiAgICAnZW51bScsXG4gICAgJ2Jvb2xlYW4nLFxuXTtcblxuZXhwb3J0IGNsYXNzIFNoYWRlckdyYXBoIHtcblxuICAgIGdldCBhc3NldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnY2MuRWZmZWN0QXNzZXQnO1xuICAgIH1cblxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gJzEuMC4wJztcbiAgICB9XG5cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdzaGFkZXItZ3JhcGgnO1xuICAgIH1cblxuICAgIGdldCBtaWdyYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgc2hhZGVyTm9kZUNsYXNzTWFwOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDtcbiAgICBzaGFkZXJDb250ZXh0OiBhbnk7XG4gICAgU2hhZGVyUHJvcGVydHk6IGFueTtcblxuICAgIC8qKlxuICAgICAqIOeUqOS6juWtmOWCqOavj+S4qiBhc3NldCDlr7nlupTnmoQgc291cmNlXG4gICAgICog5a+85YWl5YmN5YWI5o2i5oiQ77yM5oqKIHNvdXJjZSDmm7/mjaLmiJAgdGVtcCDot6/lvoTkuIvnmoQgZWZmZWN0XG4gICAgICog5a+85YWl5ZCO5Zyo5pu/5o2i5oiQ5Y6f5pys55qEIHNvdXJjZVxuICAgICAqL1xuICAgIHB1YmxpYyBjYWNoZVNvdXJjZU1hcDogTWFwPHN0cmluZywgc3RyaW5nPiA9IG5ldyBNYXAoKTtcblxuICAgIF9pbml0ZWRHcmFwaCA9IGZhbHNlO1xuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX2luaXRlZEdyYXBoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYXN5bmMgaW5pdEdyYXBoKCkge1xuICAgICAgICBpZiAodGhpcy5faW5pdGVkR3JhcGggJiYgdGhpcy5zaGFkZXJDb250ZXh0Py5zaGFkZXJUZW1wbGF0ZXNEaXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IEVkaXRvci5Nb2R1bGUuaW1wb3J0UHJvamVjdE1vZHVsZSgnZGI6Ly9zaGFkZXItZ3JhcGgvb3BlcmF0aW9uL2luZGV4LnRzJyk7XG5cbiAgICAgICAgY29uc3QgeyBTaGFkZXJQcm9wZXJ0eSB9ID0gYXdhaXQgRWRpdG9yLk1vZHVsZS5pbXBvcnRQcm9qZWN0TW9kdWxlKCdkYjovL3NoYWRlci1ncmFwaC9vcGVyYXRpb24vcHJvcGVydHkudHMnKSBhcyBhbnk7XG4gICAgICAgIHRoaXMuU2hhZGVyUHJvcGVydHkgPSBTaGFkZXJQcm9wZXJ0eTtcblxuICAgICAgICBjb25zdCB7IHNoYWRlck5vZGVNYXAsIHNoYWRlclByb3BlcnR5TWFwLCBzaGFkZXJOb2RlQ2xhc3NNYXAgfSA9IGF3YWl0IEVkaXRvci5Nb2R1bGUuaW1wb3J0UHJvamVjdE1vZHVsZSgnZGI6Ly9zaGFkZXItZ3JhcGgvZ3JhcGgvaW5kZXgudHMnKSBhcyBJTW9kdWxlT3B0aW9ucztcblxuICAgICAgICBjb25zdCB7IHNoYWRlckNvbnRleHQgfSA9IGF3YWl0IEVkaXRvci5Nb2R1bGUuaW1wb3J0UHJvamVjdE1vZHVsZSgnZGI6Ly9zaGFkZXItZ3JhcGgvb3BlcmF0aW9uL2NvbnRleHQudHMnKSBhcyBhbnk7XG4gICAgICAgIGRlY2xhcmVTaGFkZXJOb2RlQmxvY2soc2hhZGVyTm9kZU1hcCk7XG5cbiAgICAgICAgdGhpcy5zaGFkZXJOb2RlQ2xhc3NNYXAgPSBzaGFkZXJOb2RlQ2xhc3NNYXA7XG4gICAgICAgIHRoaXMuc2hhZGVyQ29udGV4dCA9IHNoYWRlckNvbnRleHQ7XG5cbiAgICAgICAgc2hhZGVyQ29udGV4dC5zaGFkZXJUZW1wbGF0ZXNEaXIgPSBhd2FpdCBFZGl0b3IuTWVzc2FnZS5yZXF1ZXN0KCdhc3NldC1kYicsICdxdWVyeS1wYXRoJywgJ2RiOi8vc2hhZGVyLWdyYXBoLy4uL2NvbXBpbGUtc2hhZGVyL3NoYWRlci10ZW1wbGF0ZXMnKSBhcyBzdHJpbmc7XG4gICAgICAgIC8vIHNoYWRlckNvbnRleHQuc2hhZGVyVGVtcGxhdGVzRGlyID0gcXVlcnlQYXRoKCdkYjovL3NoYWRlci1ncmFwaC8uLi9jb21waWxlLXNoYWRlci9zaGFkZXItdGVtcGxhdGVzJyk7XG4gICAgICAgIHRoaXMuX2luaXRlZEdyYXBoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjcmVhdGVTaGFkZXJOb2RlcyhibG9ja01hcDoge1xuICAgICAgICBbdXVpZDogc3RyaW5nXTogQmxvY2s7XG4gICAgfSkge1xuICAgICAgICBjb25zdCBzaGFkZXJOb2RlQ2xhc3NNYXAgPSB0aGlzLnNoYWRlck5vZGVDbGFzc01hcDtcbiAgICAgICAgY29uc3Qgc2hhZGVyQ29udGV4dCA9IHRoaXMuc2hhZGVyQ29udGV4dDtcblxuICAgICAgICBmb3IgKGNvbnN0IHV1aWQgaW4gYmxvY2tNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYmxvY2tNYXBbdXVpZF07XG4gICAgICAgICAgICBpZiAoIWJsb2NrLmRlc2MpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGJsb2NrLmRlc2MudHlwZTtcblxuICAgICAgICAgICAgbGV0IHNoYWRlck5vZGUgPSAoYmxvY2sgYXMgYW55KS5zaGFkZXJOb2RlO1xuICAgICAgICAgICAgaWYgKCFzaGFkZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xzID0gc2hhZGVyTm9kZUNsYXNzTWFwLmdldCh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNscykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDYW4gbm90IGZpbmQgdHlwZSBmb3IgJHt0eXBlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaGFkZXJOb2RlID0gbmV3IGNscygpO1xuICAgICAgICAgICAgICAgIHNoYWRlck5vZGUuaW5pdCgpO1xuICAgICAgICAgICAgICAgIHNoYWRlck5vZGUuYmxvY2sgPSBibG9jaztcblxuICAgICAgICAgICAgICAgIGlmICghc2hhZGVyQ29udGV4dC5hbGxOb2Rlcy5pbmNsdWRlcyhzaGFkZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXJDb250ZXh0LmFsbE5vZGVzLnB1c2goc2hhZGVyTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnUmVnaXN0ZXJMb2NhbFZhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaGFkZXJDb250ZXh0LmxvY2FsVmFycy5pbmNsdWRlcyhzaGFkZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGVyTm9kZS5uYW1lID0gYmxvY2suZ2V0SW5wdXRQaW5zTGlzdCgpWzFdLnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGVyQ29udGV4dC5sb2NhbFZhcnMucHVzaChzaGFkZXJOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0dldExvY2FsVmFyJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNoYWRlckNvbnRleHQuZ2V0TG9jYWxWYXJzLmluY2x1ZGVzKHNoYWRlck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkZXJOb2RlLm5hbWUgPSBibG9jay5nZXRJbnB1dFBpbnNMaXN0KClbMF0udmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkZXJDb250ZXh0LmdldExvY2FsVmFycy5wdXNoKHNoYWRlck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnUHJvcGVydHlOb2RlJykge1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXJOb2RlLm5hbWUgPSBibG9jay5ibG9jay5kZXRhaWxzLnRpdGxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0UGlucyA9IGJsb2NrLmdldElucHV0UGluc0xpc3QoKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRQaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpbiA9IGlucHV0UGluc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwaW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gc2hhZGVyTm9kZS5pbnB1dHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNsb3QgPSBzaGFkZXJOb2RlLmdldFNsb3RXaXRoU2xvdE5hbWUocGluLmRlc2MubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdCA9IHNoYWRlck5vZGUuZ2V0UHJvcFdpdGhOYW1lKHBpbi5kZXNjLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFZlY3RvckRhdGFUeXBlLmluY2x1ZGVzKHZhbHVlLmRhdGFUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUudmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LnZhbHVlID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLmRhdGFUeXBlID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNyZ2IgdG8gbGluZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QudmFsdWUuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudmFsdWUueCAqIHZhbHVlLnZhbHVlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS52YWx1ZS55ICogdmFsdWUudmFsdWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnZhbHVlLnogKiB2YWx1ZS52YWx1ZS56LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudmFsdWUudyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuZGF0YVR5cGUgPT09ICdlbnVtJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LnZhbHVlID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLmRhdGFUeXBlID09PSAnZHluYW1pY0VudW0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QudmFsdWUuc2V0KHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAoYmxvY2sgYXMgYW55KS5zaGFkZXJOb2RlID0gc2hhZGVyTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlYXJjaElucHV0cyhibG9jazogQmxvY2spIHtcbiAgICAgICAgY29uc3Qgc2hhZGVyTm9kZSA9IChibG9jayBhcyBhbnkpLnNoYWRlck5vZGU7XG4gICAgICAgIGNvbnN0IGlucHV0TGlzdCA9IGJsb2NrLmdldElucHV0UGluc0xpc3QoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpbiA9IGlucHV0TGlzdFtpXTtcbiAgICAgICAgICAgIGlmICghc2hhZGVyTm9kZS5pbnB1dHNbaV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY29ubmVjdFBpbiA9IHBpbi5jb25uZWN0UGluc1swXTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0UGluKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdEJsb2NrID0gY29ubmVjdFBpbi5ibG9jaztcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0U2hhZGVyTm9kZSA9IChjb25uZWN0QmxvY2sgYXMgYW55KS5zaGFkZXJOb2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RPdXRJZHggPSBjb25uZWN0UGluLmJsb2NrLmdldE91dHB1dFBpbnNMaXN0KCkuaW5kZXhPZihjb25uZWN0UGluKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0U2xvdCA9IGNvbm5lY3RTaGFkZXJOb2RlLm91dHB1dHNbY29ubmVjdE91dElkeF07XG5cbiAgICAgICAgICAgICAgICBzaGFkZXJOb2RlLmlucHV0c1tpXS5jb25uZWN0U2xvdHNbMF0gPSBjb25uZWN0U2xvdDtcbiAgICAgICAgICAgICAgICBjb25uZWN0U2xvdC5jb25uZWN0U2xvdHMucHVzaChzaGFkZXJOb2RlLmlucHV0c1tpXSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0cyhjb25uZWN0QmxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhZGVyTm9kZS5pbnB1dHNbaV0uY29ubmVjdFNsb3RzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2VuZXJhdGVNYXN0ZXJOb2RlKGdyYXBoRGF0YTogR3JhcGhEYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdEdyYXBoKCk7XG5cbiAgICAgICAgY29uc3QgZm9yZ2UgPSBuZXcgRm9yZ2UoZ3JhcGhEYXRhKTtcblxuICAgICAgICBjb25zdCBncmFwaCA9IGZvcmdlLmdldEdyYXBoKCk7XG5cbiAgICAgICAgdGhpcy5zaGFkZXJDb250ZXh0LnJlc2V0KCk7XG5cbiAgICAgICAgLy8gVE9ETyDov5nph4zov5jpnIDopoHlpITnkIblrZDlm77nmoQgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZ3JhcGguZGV0YWlscy5wcm9wZXJ0aWVzO1xuICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKCh2OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gbmV3IHRoaXMuU2hhZGVyUHJvcGVydHkodi50eXBlKTtcbiAgICAgICAgICAgICAgICBwcm9wLm5hbWUgPSB2Lm5hbWU7XG4gICAgICAgICAgICAgICAgcHJvcC5zZXRWYWx1ZSh2Lm91dHB1dFBpbnNbMF0udmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZGVyQ29udGV4dC5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJsb2NrTWFwID0gZ3JhcGguZ2V0QmxvY2tNYXAoKTtcblxuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVNoYWRlck5vZGVzKGJsb2NrTWFwKTtcblxuICAgICAgICBsZXQgbWFzdGVyQmxvY2s7XG4gICAgICAgIGZvciAoY29uc3QgdXVpZCBpbiBibG9ja01hcCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBibG9ja01hcFt1dWlkXTtcbiAgICAgICAgICAgIGlmICghYmxvY2suZGVzYykgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gYmxvY2suZGVzYy50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUuaW5jbHVkZXMoJ01hc3Rlck5vZGUnKSkge1xuICAgICAgICAgICAgICAgIG1hc3RlckJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hc3RlckJsb2NrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZmluZCBNYXN0ZXJCbG9jaycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNoYWRlckNvbnRleHQubG9jYWxWYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NWYXIgPSB0aGlzLnNoYWRlckNvbnRleHQubG9jYWxWYXJzW2ldO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZWFyY2hJbnB1dHMobG9jVmFyLmJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlYXJjaElucHV0cyhtYXN0ZXJCbG9jayk7XG5cbiAgICAgICAgY29uc3QgbWFzdGVyTm9kZSA9IChtYXN0ZXJCbG9jayBhcyBhbnkpLnNoYWRlck5vZGU7XG4gICAgICAgIHJldHVybiBtYXN0ZXJOb2RlO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBnZW5lcmF0ZUVmZmVjdEJ5R3JhcGhEYXRhKGdyYXBoRGF0YTogR3JhcGhEYXRhKSB7XG4gICAgICAgIGNvbnN0IG1hc3Rlck5vZGUgPSBhd2FpdCB0aGlzLmdlbmVyYXRlTWFzdGVyTm9kZShncmFwaERhdGEpO1xuICAgICAgICByZXR1cm4gbWFzdGVyTm9kZS5nZW5lcmF0ZUNvZGUoKTtcbiAgICB9XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgcHVibGljIGFzeW5jIGdlbmVyYXRlRWZmZWN0QnlBc3NldChhc3NldDogQXNzZXQpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplWUFNTCA9IGF3YWl0IHJlYWRGaWxlKGFzc2V0LnNvdXJjZSwgJ3V0ZjgnKTtcblxuICAgICAgICBjb25zdCBncmFwaERhdGEgPSBsb2FkKHNlcmlhbGl6ZVlBTUwpIGFzIEdyYXBoRGF0YTtcblxuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUVmZmVjdEJ5R3JhcGhEYXRhKGdyYXBoRGF0YSk7XG5cbiAgICAgICAgZW5zdXJlRGlyU3luYyh0aGlzLnRlbXBFZmZlY3RDb2RlRGlyKTtcbiAgICAgICAgYXdhaXQgd3JpdGVGaWxlKHRoaXMuZ2V0VGVtcEVmZmVjdENvZGVQYXRoKGFzc2V0KSwgY29kZSk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluWtmOWCqCBlZmZlY3QgY29kZSDmlofku7blpLlcbiAgICAgKi9cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgcHVibGljIGdldFRlbXBFZmZlY3RDb2RlUGF0aChhc3NldDogQXNzZXQpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gam9pbih0aGlzLnRlbXBFZmZlY3RDb2RlRGlyLCBgJHthc3NldC51dWlkfS5lZmZlY3RgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5blrZjlgqggZWZmZWN0IGNvZGUg6Lev5b6EXG4gICAgICovXG4gICAgcHVibGljIGdldCB0ZW1wRWZmZWN0Q29kZURpcigpIHtcbiAgICAgICAgcmV0dXJuIGpvaW4oRWRpdG9yLlByb2plY3QudG1wRGlyLCBgc2hhZGVyLWdyYXBoYCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6L+U5Zue5piv5ZCm5a+85YWl5oiQ5Yqf55qE5qCH6K6wXG4gICAgICog5aaC5p6c6L+U5ZueIGZhbHNl77yM5YiZIGltcG9ydGVkIOagh+iusOS4jeS8muWPmOaIkCB0cnVlXG4gICAgICog5ZCO57ut55qE5LiA57O75YiX5pON5L2c6YO95LiN5Lya5omn6KGMXG4gICAgICogQHBhcmFtIGFzc2V0XG4gICAgICovXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHB1YmxpYyBhc3luYyBpbXBvcnQoYXNzZXQ6IEFzc2V0KSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlRWZmZWN0QXNzZXQoYXNzZXQsIGF3YWl0IHRoaXMuZ2VuZXJhdGVFZmZlY3RCeUFzc2V0KGFzc2V0KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFNoYWRlckdyYXBoKCk7XG4iXX0=